%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     STYLE POUR LES EXPOSÉS TECHNIQUES 
%         3e année INSA de Rennes
%
%             NE PAS MODIFIER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper,11pt]{article}
\usepackage{exptech}       % Fichier (./exptech.sty) contenant les styles pour 
                           % l'expose technique (ne pas le modifier)

%\linespread{1,6}          % Pour une version destinée à un relecteur,
                           % décommenter cette commande (double interligne) 
                           
% UTILISEZ SPELL (correcteur orthographique) à accès simplifié depuis XEmacs

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{ \textbf{Rapport d'Étude Pratique : \\
Site Web pour conférence scientifique} }
\markright{Site Web de conférence scientifique} 
                           % Pour avoir le titre de l'expose sur chaque page

\author{Quentin \textsc{Dufour}, Thomas \textsc{Hareau}, \\
        Laurent \textsc{Aymard}, Jean \textsc{Chorin} \\
        \\
        Encadrant : Jean-François \textsc{Dupuy}}

\date{2015}                    % Ne pas modifier
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}          

\maketitle                 % Génère le titre
\thispagestyle{empty}      % Supprime le numéro de page sur la 1re page
\newpage


\begin{abstract}
%Resumé
\end{abstract} 

\newpage

\section{Introduction}  

La conférence IWSM se déroulera à l'INSA de Rennes en 2016. Monsieur Jean-François Dupuy, enseignant-chercheur en Mathématiques et organisateur de la conférence au niveau de l'INSA souhaitait un outil permettant aux participants de s'inscrire. Celui-ci devait être accessible de tous, ergonomique et disposer de plusieurs fonctionnalités. Il a ainsi fait part de sa requête au département INFO qui nous as proposé la réalisation de ce projet. Il s'agit donc d'un site internet ou application Web qui permet de gérer les inscriptions, les participants, les événements lors de la conférence et bien plus encore.

\bigbreak
Nous avons ainsi discuté plusieurs fois avec Monsieur Dupuy afin de cerner son besoin et finalement un cahier des charges fut dressé.
Après avoir recherché les technologies et langages nécessaires au projets. Un choix fut fait, étant donné le nombre conséquent à disposition. Nous avons ensuite commencé la réalisation de ce projet. Sont présentés à la suite de ce rapport le cahier des charges définitif, les différentes étapes de développement, les difficultés rencontrés ainsi que l'état final du projet.

\section{Cahier des Charges}
Au début du projet, nos premières réunions avec M. Dupuy consistaient en une compréhension des différents buts du projet. Nous avons pu établir un cahier des charges, résumé ici, et dont la version complète est visible sur le dépot \textit{GitHub} du projet. 

\medbreak
Tout d'abord, le nom de la conférence, IWSM devra être visible.

Le site devra présenter une partie publique, et une partie réservée à l'administration, non accessible par le grand public.

Le site web présentera les différentes fonctions suivantes : 

\subsection*{Inscription}

Chaque utilisateur pourra s'inscrire à l'IWSM. Il y indique donc des informations générales (nom, prénom, nombre de repas, ...). 

L'étape suivante consiste pour l'utilisateur à s'inscrire aux différents événements organisé. Il peut lui être demandé des informations complémentaire à ce moment. 

Les utilisateurs qui le souhaitent pourront soumettre un résumé (dans l'espoir de le voir intégré au livre produit à la suite des conférence, résumant la conférence). 

La dernière étape est le payement. Le prix est calculé automatiquement. L'utilisateur pourra télécharger un bon de commande, puis l'envoyer avec un chèque à l'INSA. 

\subsection*{Gestion des résumés}

Le résumé, lorsqu'il est soumis, n'est pas forcément parfait. Une modération sera donc mis en place. Des modérateurs valideront donc les résumés soumis. Un système de notification par mail est mis en place. 

\subsection*{Administration et personnalisation}

Un administrateur du site pourra personnaliser le site. Il pourra :

    \begin{itemize}
\item    Écrire des articles, qui seront référencés dans un "blog"
\item    Créer ou modifier une page
\item    Créer des événements
    \end{itemize}

Ces modification devront être faisable par une personne non expérimentée en informatique. 

\smallbreak

L'administrateur aura également accès à des fichiers de statistiques, résumant les différentes inscriptions aux événements. 

\section{Étude du projet}
\subsection{Architecture}

Avant de coder, nous avons clairement établi l'architecture de notre projet, sa structure afin d'avoir un code consistant et organisé.

\subsubsection{Patron de conception}

Les patrons de conception sont des modèles efficaces pour concevoir un projet. Dans le cas du web, le patron Modèle - Vue - Controlleur est majoritairement utilisé, et c'est celui que nous avons choisi. Il permet de segmenter notre code, et limiter sa duplication. La partie modèle correspond à nos données (que nous persistons, dans une base de donnée par exemple). La vue est une façon de présenter les données. Dans notre cas, nous générons du HTML. Enfin, le controlleur récupère la requête de l'utilisateur, réalise les requêtes nécessaires sur les modèles et renvoie la vue à l'utilisateur.

\subsubsection{Couche applicative et couche métier}

Nous avons voulu séparer au maximum la couche applicative (application layer) de la couche métier (business layer). En effet, la première est totalement dépendante des technologies utilisées (web, client lourd, etc), alors que la seconde est juste un modèle que nous créons, représentant notre "monde". En séparant cette dernière de la couche applicative, nous pouvons plus facilement la réutiliser dans d'autres projets. 

Le projet étant encore jeune, nous n'avons actuellement que quelques classes appartenant à la couche métier.

\subsubsection{Modèle de données}

Nous utilisons un ORM (Object-Relational Mapping), qui permet d'abstraire notre base de donnée. Ainsi la base de données est générée à partir de nos Modèles. Nous pouvons aisément passer d'une base de donnée sqlite, à une base MySQL ou encore PostgreSQL.

\begin{figure}[!h]
   \includegraphics[width=15cm]{fig/uml-models}
   \caption{\label{uml} Diagramme UML des modèles}
\end{figure}

Nous avons donc réalisé un diagramme UML de nos modèles.

\subsection{Technologies utilisées}
Ruby : Sinatra

DB : Active Record (sqlite3 mais adaptable à n'importe quels DB)

CSS : Bootstrap

\subsection{Organisation du projet}

github, issues

@TODO:JEAN

\section{Développement des fonctionnalités}

\subsection{CMS}
L'une des premières fonctionnalités ajoutées furent les Articles et les Pages. Il s'agissaient de permettre la création, la modification et la suppression d'articles et de pages sans toucher une ligne de code. Pour la mise en place d'un système de CRUD (Create, Read, Update, Delete), nous avons travaillé chacun de notre côté afin d'assimiler les bases de Sinatra, de Ruby, d'HTML et de Bootstrap lorsque cela était nécessaire. Nous avons ainsi développé ces Pages et Articles dont la gestion est très semblable.

Après avoir ajouté les tables liées dans la base (tables articles et pages), il fallait d'abord créer un formulaire Web afin de rentrer les informations de la page ou de l'article. Dans la base, les textes long devaient être indiqués en tant que \textit{text} et non \textit{string} comme fait initialement, sans quoi la taille d'enregistrement n'était pas suffisante. Les informations entrées dans le formulaires sont ensuite utilisées pour la création d'un élément Article ou Page dans la base.

Suite à la création de la page, il était nécessaire d'avoir un formulaire afin de modifier la page ou l'article aisément. Dans la partie administration, les anciennes informations sont donc affichées et il est possible d'en entrer de nouvelles. Celles-ci permettront la mise à jour de l'élément sélectionné. La page ou l'article ont ensuite été liés à des boutons permettant de les supprimer. 

Il faut ensuite afficher ces pages ou articles. Lors d'une requête au serveur, les informations de la base de données sont envoyés à l'utilisateur et forment un article ou une page sur le navigateur.

\subsection{Évènements}

\subsection{Utilisateurs}

\subsubsection{Inscription / Connexion}

\subsubsection{Validation par mail}

\subsubsection{Sécurité}

Tous d'abord, les mots de passes sont hashés et salés dynamiquement.

Roles, Cookies coté serveur, hash mot de passe

\subsubsection{Récupération de mot de passe}

\subsection{Candidatures}

Les Reviews sont les résumés envoyés par les inscrits qui souhaitent participer à la conférence. Il faut donc récupérer des fichiers soumis sur le site. Une des difficultés est donc le stockage de ces fichiers. En effet ceux-ci doivent être accessible facilement par le serveur, pour l'affichage ultérieur, mais pas par un utilisateur lambda. Sinatra et Ruby permettent la sauvegarde des fichiers envoyés. 


\bigbreak
Cependant, il a d'abord fallu créer les tables \textit{reviews} et \textit{reviewpropositions} dans la base de donnée. \textit{Reviews} contient le nom du participant, le nom de la conférence, l'état de l'inscription et est lié aux reviewpropositions. Ceux-ci sont crées à chaque nouvelle soumission de résumé. Ils contiennent le lien vers le fichier, un commentaire du participant expliquant la proposition et le lien vers la review liée. 

Ici, le lien entre les \textit{reviews}, \textit{reviewpropositions} et \textit{users} ont été difficiles à mettre en place. Il a fallu créer des associations entre les différentes tables. Après de nombreux essais, recherches et tests, les liens en dur ont été changés en \textit{references} entre les tables. 


\bigbreak
Lorsque les tables furent crées et la base de données migrée, est arrivé le problème de la sauvegarde des fichiers. Le choix fut fait de stocker les fichiers à la racine du projet et de stocker dans la base de donnée les hash MD5 des fichiers. Il s'agit d'une chaine de caractère générée selon un algorithme. Elle est différente pour chaque fichier et permet donc de les différencier dans la base. En effet, stocker le nom serait une très mauvaise idée si deux fichiers se trouvaient à avoir le même nom. 

La soumission des résumés par les utilisateurs fut donc ajoutée dans la partie profil

@TODO:JEAN

\subsection{Paramètres}

@TODO:QDUF:SETTINGS

\section{Qualité logiciel}

La qualité logiciel a été un point clé du développement de notre application web, et ce dès le début. En étant strict à ce niveau là, nous n'avons pas rencontré de problèmes particuliers lorsque la taille du projet a commencé à augmenter.

\subsection{Gestionnaire de version}

Nous avons choisi git, gestionnaire de version de dernière génération et actuellement le plus utilisé. Nous avons pu profiter de toutes ses fonctionnalités, avec entre autre les tags et les branches. Nous nous sommes basés sur un modèle existant et éprouvé\cite{nvie} et l'avons adapté à nos besoins.

Entre autre, nous avons utilisé les branches pour développer de nouvelles fonctionnalités. Une fois ces dernières terminées, nous avons fusionné la branche avec notre branche courante. Nous n'avons pas jugé utile pour le moment de différencier les branches master et develop. En effet, beaucoup d'entreprises travaillant en cycles courts considèrent les corrections de bugs comme des fonctionnalités. De plus, grâce à une chaine de test efficace, ces derniers se font rares.

\subsection{Tests unitaires}

Nous avons testé unitairement l'ensemble des classes que nous utilisions : nos modèles ainsi que toutes nos classes appartenant à notre business layer. 

Nous n'avons pas pu tester nos controllers unitairement, cas en ayant fais le choix de Sinatra, un DSL, ces derniers ne sont pas testables.

\subsection{Tests fonctionnels}

Les tests fonctionnels sont des scénarios types, pour tester le comportement de notre application dans son ensemble.

En ayant fais le choix de Capybara, nous pouvons à travers son API unique, lancer nos tests sur une grande variété de plateformes. En effet, par défaut les tests fonctionnels se font sans interface graphique, grâce au driver rack\_test qui ne lance pas de navigateur et se contente de vérifier le html généré. 

Mais sans modifier nos tests, nous pouvons lancer ces derniers avec Selenium-Webdriver, qui lance le navigateur de notre choix et simule les clics de souris et les entrées claviers.

\subsection{Intégration continue}
\begin{figure}[!h]
   \includegraphics[width=15cm]{fig/travis}
   \caption{\label{travis} Travis, outil d'intégration continue SaaS}
\end{figure}

L'intégration continue permet de s'assurer de la viabilité de notre projet au cours de son développement.

En effet, à chaque commit Travis lance un build. Pour chaque build, Travis créer une nouvelle machine virtuelle, totalement vierge. Puis, il installe les dépendances, configure l'environnement et lance les tests.

Ainsi, nous nous assurons que pour un commit donné, notre application est bien pleinement compatible avec un environnement donné et clairement défini.

Dans le cas d'un échec de build, les collaborateurs du projet recoivent un mail les alertant de l'erreur, ainsi qu'un compte rendu du build.

Nous pouvons alors sereinement déployé notre application à n'importe quel moment.

Enfin Travis permet de créer des matrices de build, qui permettent de tester le projet avec des configuration différentes. Par exemple 4 versions de ruby différentes et 3 SGBD différents. Travis lancera alors 12 builds.

\subsection{Revue de code automatique}
\begin{figure}[!h]
   \includegraphics[width=15cm]{fig/codeclimate}
   \caption{\label{codeclimate} Codeclimate, outil de revue de code SaaS}
\end{figure}

La revue de code automatique permet à notre équipe d'acquérir les bons réflexes et de s'améliorer au fur et à mesure du développement de l'application.

Cela permet aussi d'améliorer sa maintenabilité.

Codeclimate calcule aussi la couverture de tests de l'application, afin d'avoir un aperçu des fonctions testées et des fonctions qui ne sont pas testées.

\section{Déploiement}

@TODO:QDUF

\section{Conclusion} 
 


\bibliography{biblio}


\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
