%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     STYLE POUR LES EXPOSÉS TECHNIQUES 
%         3e année INSA de Rennes
%
%             NE PAS MODIFIER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper,11pt]{article}
\usepackage{exptech}       % Fichier (./exptech.sty) contenant les styles pour 
                           % l'expose technique (ne pas le modifier)

%\linespread{1,6}          % Pour une version destinée à un relecteur,
                           % décommenter cette commande (double interligne) 
                           
% UTILISEZ SPELL (correcteur orthographique) à accès simplifié depuis XEmacs

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{ \textbf{Rapport d'Étude Pratique : \\
Site Web pour conférence scientifique} }
\markright{Site Web de conférence scientifique} 
                           % Pour avoir le titre de l'expose sur chaque page

\author{Quentin \textsc{Dufour}, Thomas \textsc{Hareau}, \\
        Laurent \textsc{Aymard}, Jean \textsc{Chorin} \\
        \\
        Encadrant : Jean-François \textsc{Dupuy}}

\date{2015}                    % Ne pas modifier
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}          

\maketitle                 % Génère le titre
\thispagestyle{empty}      % Supprime le numéro de page sur la 1re page
\newpage


\begin{abstract}
Cette étude pratique résume le déroulement du projet de création de site web dynamique de gestion de conférence. Il sera utilisé par Jean-François Dupuy, pour la 31 édition de la conférence \textit{IWSM}.

Il présente la particularité de devoir être entièrement modulable. Ainsi, M. Dupuy ou une autre personne pourra s'en servir pour gérer une nouvelle conférence. 

\smallbreak
 Pour développer cette application, nous utilisons le langage \textit{Ruby}, auquel nous avons adjoins le framework \textit{Sinatra} et l'ORM Activerecord. Quant à l'interface, nous avons utilisé \textit{Bootstrap}. 

\smallbreak
Le site  permet à l'administrateur de créer différentes pages et articles, mais aussi des événements auxquels les utilisateurs ont la possibilité de s'inscrire. Lors de son inscription, l'utilisateur les sélectionne donc. À partir de ces données, et d'informations fournies, un bon de commande est généré, qui permet à l'utilisateur d'achever cette inscription.
Le site web intègre également un système de modération de résumés.


\smallbreak  

Lors du développement de l'application, nous avons fait attention à utiliser les principes de qualité logiciel. Nous utilisons donc le gestionnaire de version \textit{GIT}, effectuons des tests fonctionnels et unitaire. Les plateformes \textit{Travis} et \textit{Codeclimate} permettent de s'assurer que notre application reste fonctionnelle au cours de ses évolutions. 
\end{abstract} 

\newpage

\section{Introduction}  

La conférence \textit{IWSM} se déroulera à l'INSA de Rennes en 2016. Monsieur Jean-François Dupuy, enseignant-chercheur en Mathématiques et organisateur de la conférence au niveau de l'INSA souhaitait un outil permettant aux participants de s'inscrire. Celui-ci devait être accessible à tous, ergonomique et disposer de plusieurs fonctionnalités. Il a ainsi fait part de sa requête au département informatique qui nous a proposé la réalisation de ce projet. Il s'agit donc d'un site internet ou application Web qui permet de gérer les inscriptions, les participants, les événements lors de la conférence et bien plus encore.

\medbreak
Nous nous sommes rencontrés plusieurs fois avec Monsieur Dupuy afin de cerner ses besoins et avons établi un cahier des charges.
Après avoir recherché les technologies et langages nécessaires au projets, nous avons réalisé un choix qui nous semblait cohérent. Nous avons ensuite commencé la réalisation de ce projet. Sont présentés à la suite de ce rapport les différentes étapes de développement, les difficultés rencontrées ainsi que l'état final du projet.

\section{Étude du projet}
\subsection{Architecture}

Avant de commencer à coder, nous avons établi l'architecture de notre projet, ainsi que sa structure, afin d'avoir un code consistant et organisé.

\subsubsection{Patron de conception}

Les patrons de conception sont des modèles efficaces pour concevoir un projet. Dans le cas du web, le patron Modèle - Vue - Contrôleur est majoritairement utilisé, et c'est celui que nous avons choisi. Il permet de segmenter notre code, et limiter sa duplication. La partie modèle correspond à nos données (que nous sauvegardons, dans une base de donnée par exemple). La vue est une façon de présenter les données. Dans notre cas, nous générons du \textit{HTML}. Enfin, le contrôleur récupère la requête de l'utilisateur, réalise les requêtes nécessaires sur les modèles et renvoie la vue à l'utilisateur.

\subsubsection{Modèle de données}
\label{mdd}

\begin{figure}[!h]
   \includegraphics[width=15cm]{fig/uml-models}
   \caption{\label{uml} Diagramme \textit{UML} des modèles}
\end{figure}
Nous utilisons un ORM (Object-Relational Mapping), qui permet d'abstraire notre base de donnée. Ainsi la base de données est générée à partir de nos Modèles. Nous pouvons aisément passer d'une base de donnée sqlite, à une base MySQL ou encore PostgreSQL.

Nous avons donc réalisé un diagramme \textit{UML} de nos modèles.

\subsection{Technologies utilisées}
Le choix des technologies a été fait dans le but de créer un projet léger, et simple à mettre en place. 
\paragraph*{Ruby et Sinatra} Nous avons choisi d'utiliser le langage Ruby de concert avec le framework Sinatra. Ce dernier est un DSL (Domain Specific Language), et est plus léger que d'autres gros frameworks comme \textit{Ruby on Rails}. Grâce à leur forte modularité, nous avons pu réutiliser de nombreux composants de base de \textit{Ruby on Rails}. 

\paragraph{SGBD}
Nous utilisons un SGBD relationnel à travers l'utilisation de l'ORM \textit{Activerecord}. Pour les développements, nous avons choisi d'utiliser une base de donnée \textit{sqlite3}, plus facile de configuration. Cependant, en changeant les paramètres, il est très facile de se connecter à une base \textit{MySQL} ou \textit{PostgreSQL}.

\paragraph{Frontend}
Afin d'uniformiser l'apparence du site web sur tous les navigateurs, de réaliser facilement un site web responsive et de minimiser les développements en CSS, nous avons choisi d'utiliser le framework \textit{Bootstrap}. Ce dernier livre aussi quelques élèments d'interfaces, très appréciés pour leur clarté.

\subsection{Organisation du projet}
Pour l'organisation, la méthode Agile fut choisie : nous devions donc poser différentes deadlines et présenter régulièrement notre travail à l'encadrant. Les différentes dates de rendu ont été placées afin d'avoir une base de travail convenable, et que chacun puisse s'y retrouver dans le travail à effectuer. Les différentes étapes furent les suivantes : gestion des articles et des pages, gestion des événements et des utilisateurs, gestion des résumés et des paramètres du site.


\medbreak
Il fut donc décidé d'utiliser \textit{GitHub}, gestionnaire de version de dernière génération et actuellement le plus utilisé. Nous avons pu profiter de toutes ses fonctionnalités, avec entre autre les tags et les branches. Nous nous sommes basés sur un modèle existant et éprouvé\cite{nvie} et l'avons adapté à nos besoins.

D'autres fonctionnalités de \textit{GitHub} ont également été très utiles comme les \textit{issues}. Les \textit{issues} nous permettaient de préciser différents soucis dans la construction ou le développement du site, ou de détailler les fonctionnalités à ajouter au site. 

\section{Développement des fonctionnalités}

\subsection{CMS}
L'une des premières fonctionnalités ajoutées furent les Articles et les Pages. Il s'agissaient de permettre la création, la modification et la suppression d'articles et de pages sans toucher une ligne de code. Un système de CRUD (Create, Read, Update, Delete) a été mis en place pour ces Pages et Articles dont la gestion est très semblable.

Après avoir ajouté les tables liées dans la base (\textit{articles} et \textit{pages}), il fallait d'abord créer un formulaire Web afin de rentrer les informations de la page ou de l'article. Elles sont ensuite utilisées pour la création d'un élément Article ou Page dans la base.

Suite à la création de la page, il était nécessaire d'avoir un formulaire afin de modifier la page ou l'article aisément. Dans la partie administration il est possible d'entrer de nouvelles informations. Celles-ci permettront la mise à jour de l'élément sélectionné. La page ou l'article ont ensuite été liés à des boutons permettant de les supprimer. 

Il faut ensuite afficher ces pages ou articles. Lors d'une requête au serveur, les informations de la base de données sont envoyés à l'utilisateur et forment un article ou une page sur le navigateur.

\subsection{Évènements}

Les événements comportent trois aspects : la description de l'événement, la gestion de l'inscrition à l'événement, et la gestion des statistiques qui permettent de télécharger un fichier Excel, qui résumera toutes les inscriptions. 

Nous avons séparé le travail en petites étapes, construisant tout d'abord une base, puis en la complexifiant peu à peu. 
\medbreak
%\subsubsection{La création des événements}

La première étape consiste en la création du \textit{CRUD} de l'événement. Cette étape est plutôt simple, puisqu'un événement n'est en lui même qu'un article avec quelques colonnes en plus : les dates de début et de fin de l'événement, le nombre limite de place, et l'activation des inscriptions. 

\medbreak
%\subsubsection{La création du formulaire d'inscription}
Une fois le \textit{CRUD} de l'événement terminé, nous y avons ajouté la possibilité de créer un élément de formulaire. En effet, lorsque l'utilisateur s'inscrit à l'événement, on souhaite qu'il puisse remplir un formulaire pour ajouter des informations complémentaire (imaginons qu'un événement soit en hauteur, il peut être utile de savoir si l'utilisateur à le vertige\dots). 

\label{diffuculté_relation}

Cette création est légèrement plus complexe que la création d'un article. Nous avons recontré une grosse difficulté ici : l'élément doit être relié à un événement. Il s'agit donc d'une relation \textit{many to one}. \textit{Activerecord} simplifier normalement ce processus. Cependant, la configuration n'a pas été correctement effectuée dans un premier temps. Il fallait alors écrire une grande partie des requêtes \textit{SQL} à la main. Cela a été une légère perte de temps, puisqu'il a fallu, quelques jours plus tard, corrigé cette maladresse. 
\medbreak
%\subsubsection{La gestion des inscriptions}
Lorsque les éléments de formulaires furent correctement configurés,  nous avons implémenté l'inscription à un événement. Celle ci utilise également des relations \textit{SQL}, cependant la technologie nous étais connue à ce moment. Cette partie a donc été relativement rapide. 

Deux éléments sont à vérifié : l'utilisateur doit bien remplir les différents champs, et le site doit vérifier que le nombre limite de place n'a pas été dépassé.
\medbreak
%\subsubsection{La gestion des statistiques}

Par la suite, nous avons mis en place la gestion des statistiques. 
 L'administrateur peut visualiser les statistiques de deux manières différentes (soit sur Excel, soit directement sur le site web). 
 

\subsection{Utilisateurs}

\subsubsection{Inscription / Connexion}

L'inscription et la connexion de l'utilisateur se font via un formulaire. Nous avons choisi l'email comme identifiant unique. 

L'inscription se cantonne à créer un utilisateur en base de donnée, puis passe la main à la validation de l'email.

\subsubsection{Validation de l'email}

La validation de l'email se fait via l'envoi d'un email à l'adresse indiquée afin de vérifier que cette dernière est bien correcte et appartient bien à l'utilisateur. Ce dernier n'a plus qu'à cliquer sur un lien, et son compte sera validé. Afin d'améliorer l'expérience utilisateur, ce dernier est aussi authentifié. 

Côté serveur, un jeton est généré pour l'utilisateur, à usage unique. A partir de ce dernier et de l'email de l'utilisateur, un lien est généré, et envoyé par email. Lors du clic sur le lien, si les informations correspondent, l'utilisateur passe authentifié et est automatiquement connecté pour cette session. Le jeton est alors détruit.

\subsubsection{Sécurité}

Tous d'abord, les mots de passes sont hashés et salés dynamiquement. Le niveau de sécurité est hautement amélioré par cette méthode. 

Enfin, une fois authentifié, l'utilisateur est géré via une session, les informations sont donc stockées côté serveur et ne peuvent donc pas être modifiées par l'utilisateur. Ce qui serait le cas si elles étaient stockées directement dans le cookie.

Plusieurs rôles sont définis : Non authentifié, Compte Non validé, Utilisateur, Modérateur et Administrateur. Chaque page peut être restreinte à un rôle particulier.

\subsubsection{Récupération de mot de passe}

La récupération de mot de passe fonctionne sensiblement pareil que la validation par email, via l'utilisation des jetons uniques.

\subsection{Candidatures}

Les Reviews sont les résumés envoyés par les inscrits qui souhaitent participer à la conférence. Une des difficultés est donc le stockage de ces fichiers. En effet ceux-ci doivent être accessible facilement par le serveur, pour l'affichage ultérieur, mais pas par un utilisateur lambda. Sinatra et Ruby permettent la sauvegarde des fichiers envoyés à travers le protocole \textit{HTTP}.


\medbreak
Cependant, il a d'abord fallu créer les tables \textit{reviews} et \textit{reviewpropositions} dans la base de donnée. \textit{Reviews} contient le nom du participant, le nom de la conférence, l'état de l'inscription et est lié aux reviewpropositions. Ceux-ci sont crées à chaque nouvelle soumission de résumé. Ils contiennent le lien vers le fichier, un commentaire du participant expliquant la proposition et le lien vers la review liée. 

Ici, le lien entre les \textit{reviews}, \textit{reviewpropositions} et \textit{users} ont été difficiles à mettre en place, pour les mêmes raisons que celle évoquées dans la partie \ref{diffuculté_relation}. 


\medbreak
Lorsque les tables furent crées et la base de données migrée, est arrivé le problème de la sauvegarde des fichiers. Le choix fut fait de stocker les fichiers à la racine du projet et de stocker dans la base de donnée les hash MD5 des fichiers. Il s'agit d'une chaine de caractère générée selon un algorithme. Elle est différente pour chaque fichier et permet donc de les différencier dans la base. En effet, stocker le nom serait une très mauvaise idée si deux fichiers se trouvaient à avoir le même nom. 


\subsection{Paramètres}

Nous avons voulu créer une plateforme de gestion de conférence assez ouverte. Nous voulons donc que cette dernière puisse être réutilisable pour d'autres évènements, c'est pourquoi de nombreuses données peuvent être modifiées.

Entre autre les informations de base du site : nom, slogan, couverture. Mais aussi des informations de paiement, le serveur de mail utilisé...

\section{Qualité logiciel}

La qualité logiciel a été un point clé du développement de notre application web, et ce dès le début. En étant strict à ce niveau là, nous n'avons pas rencontré de problèmes particuliers lorsque la taille du projet a commencé à augmenter.


\subsection{Tests unitaires}

Nous avons testé unitairement l'ensemble des classes que nous utilisions : nos modèles ainsi que toutes nos classes appartenant à notre business layer. 

Nous n'avons pas pu tester nos controllers unitairement, car en ayant fais le choix de Sinatra, un DSL, ces derniers ne sont pas testables.

\subsection{Tests fonctionnels}

Les tests fonctionnels sont des scénarios types, pour tester le comportement de notre application dans son ensemble.

En ayant fais le choix de \textit{Capybara}, nous pouvons à travers son API unique, lancer nos tests sur une grande variété de plateformes. En effet, par défaut les tests fonctionnels se font sans interface graphique, grâce au driver \verb!rack_test! qui ne lance pas de navigateur et se contente de vérifier le html généré. 

Mais sans modifier nos tests, nous pouvons lancer ces derniers avec \textit{Selenium-Webdriver}, qui lance le navigateur de notre choix et simule les clics de souris et les entrées claviers.

\subsection{Intégration continue}

L'intégration continue permet de s'assurer de la viabilité de notre projet au cours de son développement.

En effet, à chaque commit \textit{Travis} lance un build. Pour chaque build, \textit{Travis} créer une nouvelle machine virtuelle, totalement vierge. Puis, il installe les dépendances, configure l'environnement et lance les tests.

\subsection{Revue de code automatique}

La revue de code automatique permet à notre équipe d'acquérir les bons réflexes et de s'améliorer au fur et à mesure du développement de l'application.

Cela permet aussi d'améliorer sa maintenabilité.

\textit{Codeclimate} calcule aussi la couverture de tests de l'application, afin d'avoir un aperçu des fonctions testées et des fonctions qui ne sont pas testées.

\section{Déploiement}

Nous n'avons pas encore eu l'occasion de déployer notre projet en production, mais avons un serveur de démo (UAT, User Acceptance Testing).

Il est d'ailleurs actuellement accessible à l'URL suivante : http://suzanne.deuxfleurs.fr

Nous avons choisi un conteneur LXC pour le compartimenter du reste du système, avec une distribution Debian stable.

Nous recommandons l'utilisation du serveur web thin en lieu et place du serveur de développement webrick. En effet, thin est plus optimisé. De plus, il est possible de mettre en place un reverse proxy, comme nginx ou varnish devant le serveur ruby, qui peut servir les fichiers statiques directement sans avoir à passer par notre serveur, nécessairement plus lent.

Dans le cas d'une utilisation professionnelle, il est aussi fortement recommandé d'utiliser une connexion chiffrée avec un certificat valide (https), afin d'éviter la transmission d'informations sensibles en clair. 

\section{Conclusion} 
 
Le développement de cette étude pratique nous a permis de nous mettre en situation d'une gestion de projet, étape essentiel dans la vie d'un élève-ingénieur. Nous avons expérimenté le développement en groupe, mais nous avons pu également aborder la relation client.

Nous avons commencé par comprendre les besoin de notre encadrant puis  de trouver les technologies adaptés. Nous avons aussi collaboré pour implémenter chaque fonctionnalité une à une, en s'assurant qu'elles correspondent à ce qu'il attendais.

La séparation des tâches nous a permis de nous focaliser chacun sur notre travail à réaliser, et aussi d'optimiser le temps d'apprentissage, chacun apprend ce dont il a besoin.

Dans le cadre d'un prolongement du développement du projet, il est envisageable d'implémenter une interface dynamique grâce à Javascript.
Nous avons construit un système complexe composé de plusieurs technologies, tout en vérifiant en permanence que ce que l'on développe correspond au besoin de notre encadrant. 



\bibliography{biblio}


\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
